
import React, { useState } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { QuizResult } from '@/entities/QuizResult';
import { quizQuestions, cbtiProfiles } from '../components/quiz/quizData';
import QuestionCard from '../components/quiz/QuestionCard';
import ResultsDisplay from '../components/quiz/ResultsDisplay';
import { Sparkles, Brain } from 'lucide-react';

export default function Quiz() {
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [answers, setAnswers] = useState([]);
  const [showResults, setShowResults] = useState(false);
  const [cbtiResult, setCbtiResult] = useState(null);

  const currentQuestion = quizQuestions[currentQuestionIndex];
  // isLastQuestion variable is no longer directly used for navigation logic within handleAnswer,
  // but might be useful for display purposes or other parts of the component.
  // We'll keep it for now, but the navigation logic uses `nextIndex >= quizQuestions.length`.
  const isLastQuestion = currentQuestionIndex === quizQuestions.length - 1; 

  const calculateCBTI = (userAnswers) => {
    let risk_attitude_score = 0;
    let decision_style_score = 0;
    let time_horizon_score = 0;
    let information_preference_score = 0;

    // --- New Risk Attitude Calculation ---
    const q1Answer = userAnswers.find(a => a.question_id === 1);
    const q1Score = q1Answer ? q1Answer.score : 0;
    
    let riskLetter = '';
    if (q1Score >= 7) {
      riskLetter = 'T';
    } else {
      let weightedRiskScore = 0;
      userAnswers.forEach(ans => {
        const question = quizQuestions.find(q => q.id === ans.question_id);
        if (question && question.dimension === 'risk_attitude' && question.weight) {
          weightedRiskScore += ans.score * question.weight;
        }
      });
      
      riskLetter = weightedRiskScore <= 3.5 ? 'A' : 'T';
    }
    // --- End of New Risk Attitude Calculation ---

    // --- Sum scores for each dimension for DB and other calculations ---
    userAnswers.forEach(answer => {
      const question = quizQuestions.find(q => q.id === answer.question_id);
      if (question) {
        switch (question.dimension) {
          case 'risk_attitude':
            risk_attitude_score += answer.score;
            break;
          case 'decision_style':
            decision_style_score += answer.score;
            break;
          case 'time_horizon':
            time_horizon_score += answer.score;
            break;
          case 'information_preference':
            information_preference_score += answer.score;
            break;
        }
      }
    });

    // --- New Decision Style Calculation ---
    // Assuming 'decision_style_score' is the sum of scores for decision style questions.
    // If there are exactly 3 decision style questions, the average is sum / 3.
    // The actual number of questions needs to be consistent with quizData.
    // For this implementation, we proceed assuming a fixed divisor of 3, based on previous context
    // where decision_style_score was linked to a threshold of 25 (implying multiple questions).
    const decisionStyleQuestionsCount = quizQuestions.filter(q => q.dimension === 'decision_style').length;
    const decisionAverage = decisionStyleQuestionsCount > 0 ? decision_style_score / decisionStyleQuestionsCount : 0;
    const decisionLetter = decisionAverage < 2.5 ? 'I' : 'R';
    // --- End of New Decision Style Calculation ---

    // Determine letters for other dimensions based on simple sum thresholds
    const timeHorizonLetter = time_horizon_score >= 12 ? 'S' : 'L';
    const informationPrefLetter = information_preference_score >= 12 ? 'C' : 'O';

    const cbtiCode = [
      riskLetter,
      decisionLetter,
      timeHorizonLetter,
      informationPrefLetter,
    ].join('');
    
    return {
      cbtiCode,
      dimensionScores: {
        risk_attitude: risk_attitude_score,
        decision_style: decision_style_score,
        time_horizon: time_horizon_score,
        information_preference: information_preference_score,
      },
      profile: cbtiProfiles[cbtiCode]
    };
  };

  const handleAnswer = async (score) => {
    const newAnswer = {
      question_id: currentQuestion.id,
      score: score
    };
    
    const updatedAnswers = [...answers, newAnswer];
    setAnswers(updatedAnswers);

    let nextIndex = currentQuestionIndex + 1;

    // Special skip logic for Question 1
    if (currentQuestion.id === 1 && score >= 7) {
      // Find the index of the last question that belongs to the 'risk_attitude' dimension
      const lastRiskQuestionIndex = quizQuestions.findLastIndex(q => q.dimension === 'risk_attitude');
      if (lastRiskQuestionIndex !== -1) {
        nextIndex = lastRiskQuestionIndex + 1;
      }
    }

    if (nextIndex >= quizQuestions.length) {
      // Quiz is finished, calculate results
      const result = calculateCBTI(updatedAnswers);
      
      // Save to database
      try {
        await QuizResult.create({
          cbti_code: result.cbtiCode,
          user_answers: updatedAnswers,
          dimension_scores: result.dimensionScores
        });
      } catch (error) {
        console.error('Error saving quiz result:', error);
      }

      setCbtiResult(result);
      setShowResults(true);
    } else {
      setCurrentQuestionIndex(nextIndex);
    }
  };

  const handleRestart = () => {
    setCurrentQuestionIndex(0);
    setAnswers([]);
    setShowResults(false);
    setCbtiResult(null);
  };

  if (showResults && cbtiResult) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-50 via-amber-50/30 to-slate-100 p-4 md:p-8">
        <div className="container mx-auto py-8">
          <ResultsDisplay 
            profile={cbtiResult.profile} 
            onRestart={handleRestart}
          />
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-amber-50/30 to-slate-100 p-4 md:p-8">
      <div className="container mx-auto py-8">
        {/* Header */}
        {currentQuestionIndex === 0 && (
          <motion.div
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            className="text-center mb-12"
          >
            <div className="flex items-center justify-center gap-3 mb-6">
              <div className="w-16 h-16 bg-gradient-to-br from-amber-500 to-amber-600 rounded-2xl flex items-center justify-center shadow-lg">
                <Brain className="w-8 h-8 text-white" />
              </div>
              <div className="text-left">
                <h1 className="text-3xl md:text-4xl font-bold text-slate-900">CBTI 測驗</h1>
                <p className="text-slate-600">發現你的加密投資人格</p>
              </div>
            </div>
            <div className="max-w-2xl mx-auto">
              <p className="text-lg text-slate-700 leading-relaxed">
                通過我們的12題綜合評估，發現你獨特的加密投資人格類型並獲得個人化策略建議。
              </p>
            </div>
          </motion.div>
        )}

        {/* Quiz Content */}
        <AnimatePresence mode="wait">
          <QuestionCard
            key={currentQuestion.id}
            question={currentQuestion}
            onAnswer={handleAnswer}
            currentQuestion={currentQuestionIndex + 1}
            totalQuestions={quizQuestions.length}
          />
        </AnimatePresence>

        {/* Footer */}
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.8 }}
          className="text-center mt-12"
        >
          <p className="text-sm text-slate-500">
            Powered by SuperIntent • CBTI Personality Framework
          </p>
        </motion.div>
      </div>
    </div>
  );
